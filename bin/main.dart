import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:plover_json_convert/chords.dart';
import 'package:plover_json_convert/plover_json_convert.dart';

void main(List<String> arguments) {
  final dictionary = <Chords, String>{};

  for (final filename in arguments.reversed) {
    dictionary.addAll(loadDictionary(filename));
  }

  final byStrokes = splitByStrokeCount(dictionary);
  print('// *** Autogenerated file ***');
  print('');
  print('// This is build using the following dictionaries');
  for (final filename in arguments) {
    print('// * ${filename.split('/').last}');
  }
  print('');
  print('#include "main_dictionary.h"');
  print('#include "map_dictionary_definition.h"');
  print('');

  final wordToOffsetMap = writeTextBlock(dictionary);

  for (var i = 0; i < byStrokes.length; ++i) {
    writeStrokeCount(i + 1, byStrokes[i], wordToOffsetMap);
    print('');
  }

  print('');
  print('const StenoMapDictionaryStrokesDefinition strokes[] = {');
  for (var i = 1; i <= byStrokes.length; ++i) {
    print(
      '  {.hashMapSize = hashMapSize$i, .data = data$i, .offsets = offsets$i},',
    );
  }
  print('};');
  print('');

  print(
      'constexpr StenoMapDictionaryDefinition MainDictionary::definition = {');
  print('  0x3244534a,'); // STENO_MAP_DICTIONARY_MAGIC
  print('  ${byStrokes.length},');
  print('  textBlock,');
  print('  strokes,');
  print('};');
}

class HashEntry {
  HashEntry(this.chords, this.text);

  final Chords chords;
  final String text;
}

void writeStrokeCount(
  int strokeCount,
  Map<Chords, String> map,
  Map<String, int> wordToOffsetMap,
) {
  if (map.isEmpty) {
    print('const size_t hashMapSize$strokeCount = 0;');
    print('const uint8_t *const data$strokeCount = nullptr;');
    print('const StenoHashMapEntryBlock *const offsets$strokeCount = nullptr;');
    return;
  }

  // Target duty cycle of 66%.
  final minimumHashMapSize = map.length + (map.length >> 1);
  var hashMapSize = 32;
  while (hashMapSize < minimumHashMapSize) {
    hashMapSize <<= 1;
  }

  // Build hashmap.
  final hashMap = List<HashEntry?>.filled(hashMapSize, null);
  map.forEach((key, value) {
    final hashValue = key.crc32Hash();
    var index = hashValue % hashMapSize;
    while (hashMap[index] != null) {
      index = (index + 1) % hashMapSize;
    }
    hashMap[index] = HashEntry(key, value);
  });

  print('const size_t hashMapSize$strokeCount = $hashMapSize;');

  writeData(strokeCount, hashMap, map, wordToOffsetMap);
}

extension UInt32ByteData on ByteData {
  void setUint24(int dataOffset, int value) {
    setUint8(dataOffset, value & 0xff);
    setUint8(dataOffset + 1, (value >> 8) & 0xff);
    setUint8(dataOffset + 2, (value >> 16) & 0xff);
  }
}

void writeData(
  int strokeCount,
  List<HashEntry?> hashMap,
  Map<Chords, String> dictionary,
  Map<String, int> wordToOffsetMap,
) {
  final data = Uint8List(dictionary.length * 3 * (1 + strokeCount));
  final dataView = ByteData.view(data.buffer);

  // Build data
  var offset = 1;
  for (var i = 0; i < hashMap.length; ++i) {
    final hashEntry = hashMap[i];
    if (hashEntry == null) {
      continue;
    }
    final chords = hashEntry.chords.chords;
    final text = hashEntry.text;

    final dataOffset = (offset - 1) * (1 + strokeCount) * 3;
    dataView.setUint24(dataOffset, wordToOffsetMap[text]!);

    for (var i = 0; i < strokeCount; ++i) {
      dataView.setUint24(dataOffset + (i + 1) * 3, chords[i].toMask());
    }
    ++offset;
  }

  writeUint8List('data$strokeCount', data);

  // Build hashmap offsets.
  final hashmapEntryCount = hashMap.length ~/ 32;

  var startOffset = 1;
  print('const StenoHashMapEntryBlock offsets$strokeCount[] = {');
  for (var i = 0; i < hashmapEntryCount; ++i) {
    var blockOffset = startOffset;
    var blockMask = 0;
    for (var j = 0; j < 32; ++j) {
      final chords = hashMap[32 * i + j];
      if (chords == null) {
        continue;
      }
      blockMask |= (1 << j);
      ++startOffset;
    }
    final maskText = blockMask.toRadixString(16).padLeft(2, '8');
    print('  { $blockOffset, 0x$maskText },');
  }

  print('};');
}

Map<String, int> writeTextBlock(Map<Chords, String> map) {
  final wordToOffsetMap = <String, int>{};
  final builder = BytesBuilder();

  final wordList = map.values.toList()..sort((a, b) => b.length - a.length);

  builder.addByte(0);
  for (final word in wordList) {
    if (wordToOffsetMap.containsKey(word)) continue;

    final start = builder.length;
    wordToOffsetMap[word] = start;
    builder.add(utf8.encode(word));
    builder.addByte(0);

    for (var i = 1; i < word.length - 1; ++i) {
      final prefix = word.substring(0, i);
      final suffix = word.substring(i);
      final offset = utf8.encode(prefix).length;
      wordToOffsetMap[suffix] = start + offset;
    }
  }

  writeUint8List('textBlock', builder.toBytes());

  return wordToOffsetMap;
}

void writeUint8List(String name, Uint8List data) {
  stdout.write('const uint8_t $name[${data.length}] = {');
  for (var i = 0; i < data.length; ++i) {
    if (i % 16 == 0) stdout.write('\n ');
    stdout.write(' 0x${data[i].toRadixString(16).padLeft(2, '0')},');
  }
  stdout.write('\n};\n');
}
